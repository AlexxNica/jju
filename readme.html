<!DOCTYPE html><html><head><title>Readme - jju library</title><!--link(rel='stylesheet', href='https://netdna.bootstrapcdn.com/bootstrap/3.1.0/css/bootstrap.min.css')--><link rel="stylesheet" href="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css"><link rel="stylesheet" href="src/style.css"><style>textarea { font-family: monospace; }
tr.data:hover { cursor: pointer }
.forkme { position: absolute; top: 0; right: 0; border: 0; z-index: 1 }
.bootstrap-tagsinput { width: 100% }</style><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script><script src="https://netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script><script src="jju.js"></script></head><body><a href="https://github.com/rlidwka/jju"><img src="https://github-camo.global.ssl.fastly.net/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png" class="forkme"></a><nav role="navigation" class="navbar navbar-default"><div class="container-fluid"><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href="index.html">Home</a></li><li class="active"><a href="readme.html">Readme</a></li><li><a href="editor.html">Demo - Editor</a></li><li><a href="tokenizer.html">Demo - Tokenizer</a></li></ul></div></div></nav><div class="container"><div class="row"><p><code>jju</code> - a set of utilities to work with JSON / JSON5 documents</p>
<h2><a name="installation" class="anchor" href="#installation"><span class="header-link"></span></a>Installation</h2><pre><code>npm <span class="hljs-keyword">install</span> jju
</code></pre><h2><a name="usage" class="anchor" href="#usage"><span class="header-link"></span></a>Usage</h2><p>This module provides following functions:</p>
<ol>
<li><a href="#jjuparse-function">jju.parse()</a> parses json/json5 text and returns a js value it corresponds to</li>
<li><a href="#jjustringify-function">jju.stringify()</a> converts js value to an appropriate json/json5 text</li>
<li><a href="#jjutokenize-function">jju.tokenize()</a> parses json/json5 text and returns an array of tokens it consists of (<a href="http://rlidwka.github.io/jju/tokenizer.html">see demo</a>)</li>
<li><a href="#jjuanalyze-function">jju.analyze()</a> parses json/json5 text and tries to guess indentation, quoting style, etc.</li>
<li><a href="#jjuupdate-function">jju.update()</a> changes json/json5 text, preserving original formatting as much as possible (<a href="http://rlidwka.github.io/jju/editor.html">see demo</a>)</li>
</ol>
<p>All functions are able to work with a standard JSON documents. <code>jju.parse()</code> and <code>jju.stringify()</code> are better in some cases, but slower than native <code>JSON.parse()</code> and <code>JSON.stringify()</code> versions. Detailed description see below.</p>
<h3><a name="jjuparse-function" class="anchor" href="#jjuparse-function"><span class="header-link"></span></a>jju.parse() function</h3><pre><code class="lang-js"><span class="hljs-comment">/*
 * Main syntax:
 *
 * `text` - text to parse, type: String
 * `options` - parser options, type: Object
 */</span>
jju.parse(text[, options])

<span class="hljs-comment">// compatibility syntax</span>
jju.parse(text[, reviver])
</code></pre>
<p>Options:</p>
<ul>
<li><p>reserved_keys - what to do with reserved keys (String, default=&quot;ignore&quot;)</p>
<ul>
<li>&quot;ignore&quot; - ignore reserved keys</li>
<li>&quot;throw&quot; - throw SyntaxError in case of reserved keys</li>
<li><p>&quot;replace&quot; - replace reserved keys, this is the default JSON.parse behaviour, unsafe</p>
<p>Reserved keys are keys that exist in an empty object (<code>hasOwnProperty</code>, <code>__proto__</code>, etc.).</p>
</li>
</ul>
</li>
</ul>
<pre><code class="lang-js"><span class="hljs-comment">// 'ignore' will cause reserved keys to be ignored:</span>
parse(<span class="hljs-string">'{hasOwnProperty: 1}'</span>, {reserved_keys: <span class="hljs-string">'ignore'</span>}) == {}
parse(<span class="hljs-string">'{hasOwnProperty: 1, x: 2}'</span>, {reserved_keys: <span class="hljs-string">'ignore'</span>}).hasOwnProperty(<span class="hljs-string">'x'</span>) == <span class="hljs-literal">true</span>

<span class="hljs-comment">// 'throw' will cause SyntaxError in these cases:</span>
parse(<span class="hljs-string">'{hasOwnProperty: 1}'</span>, {reserved_keys: <span class="hljs-string">'throw'</span>}) == <span class="hljs-built_in">SyntaxError</span>

<span class="hljs-comment">// 'replace' will replace reserved keys with new ones:</span>
parse(<span class="hljs-string">'{hasOwnProperty: 1}'</span>, {reserved_keys: <span class="hljs-string">'throw'</span>}) == {hasOwnProperty: <span class="hljs-number">1</span>}
parse(<span class="hljs-string">'{hasOwnProperty: 1, x: 2}'</span>, {reserved_keys: <span class="hljs-string">'ignore'</span>}).hasOwnProperty(<span class="hljs-string">'x'</span>) == <span class="hljs-built_in">TypeError</span>
</code></pre>
<ul>
<li><p>null_prototype - create object as Object.create(null) instead of &#39;{}&#39; (Boolean)</p>
<p>if <code>reserved_keys != &#39;replace&#39;</code>, default is <strong>false</strong></p>
<p>if <code>reserved_keys == &#39;replace&#39;</code>, default is <strong>true</strong></p>
<p>It is usually unsafe and not recommended to change this option to false in the last case.</p>
</li>
<li><p>reviver - reviver function - Function</p>
<p>This function should follow JSON specification</p>
</li>
<li><p>mode - operation mode, set it to &#39;json&#39; if you want to throw on non-strict json files (String)</p>
</li>
</ul>
<h3><a name="jjustringify-function" class="anchor" href="#jjustringify-function"><span class="header-link"></span></a>jju.stringify() function</h3><pre><code class="lang-js"><span class="hljs-comment">/*
 * Main syntax:
 *
 * `value` - value to serialize, type: *
 * `options` - serializer options, type: Object
 */</span>
jju.stringify(value[, options])

<span class="hljs-comment">// compatibility syntax</span>
jju.stringify(value[, replacer [, indent])
</code></pre>
<p>Options:</p>
<ul>
<li><p>ascii - output ascii only (Boolean, default=false)
If this option is enabled, output will not have any characters except of 0x20-0x7f.</p>
</li>
<li><p>indent - indentation (String, Number or Boolean, default=&#39;\t&#39;)
This option follows JSON specification.</p>
</li>
<li><p>quote - enquoting char (String, &quot;&#39;&quot; or &#39;&quot;&#39;, default=&quot;&#39;&quot;)</p>
</li>
<li><p>quote_keys - whether keys quoting in objects is required or not (String, default=false)
If you want <code>{&quot;q&quot;: 1}</code> instead of <code>{q: 1}</code>, set it to true.</p>
</li>
<li><p>replacer - replacer function or array (Function or Array)
This option follows JSON specification.</p>
</li>
<li><p>no_trailing_comma = don&#39;t output trailing comma (Boolean, default=false)
If this option is set, arrays like this <code>[1,2,3,]</code> will never be generated. Otherwise they may be generated for pretty printing.</p>
</li>
<li><p>mode - operation mode, set it to &#39;json&#39; if you want correct json in the output (String)</p>
<p>Currently it&#39;s either &#39;json&#39; or something else. If it is &#39;json&#39;, following options are implied:</p>
<ul>
<li>options.quote = &#39;&quot;&#39;</li>
<li>options.no_trailing_comma = true</li>
<li>options.quote_keys = true</li>
<li>&#39;\x&#39; literals are not used</li>
</ul>
</li>
</ul>
<h3><a name="jjutokenize-function" class="anchor" href="#jjutokenize-function"><span class="header-link"></span></a>jju.tokenize() function</h3><pre><code class="lang-js"><span class="hljs-comment">/*
 * Main syntax:
 *
 * `text` - text to tokenize, type: String
 * `options` - parser options, type: Object
 */</span>
jju.tokenize(text[, options])
</code></pre>
<p>Options are the same as for the <code>jju.parse</code> function.</p>
<p>Return value is an array of tokens, where each token is an object:</p>
<ul>
<li>raw (String) - raw text of this token, if you join all raw&#39;s, you will get the original document</li>
<li>type (String) - type of the token, can be <code>whitespace</code>, <code>comment</code>, <code>key</code>, <code>literal</code>, <code>separator</code> or <code>newline</code></li>
<li>stack (Array) - path to the current token in the syntax tree</li>
<li>value - value of the token if token is a <code>key</code> or <code>literal</code></li>
</ul>
<p>You can check tokenizer for yourself using <a href="http://rlidwka.github.io/jju/tokenizer.html">this demo</a>.</p>
<h3><a name="jjuanalyze-function" class="anchor" href="#jjuanalyze-function"><span class="header-link"></span></a>jju.analyze() function</h3><pre><code class="lang-js"><span class="hljs-comment">/*
 * Main syntax:
 *
 * `text` - text to analyze, type: String
 * `options` - parser options, type: Object
 */</span>
jju.analyze(text[, options])
</code></pre>
<p>Options are the same as for the <code>jju.parse</code> function.</p>
<p>Return value is an object defining a programming style in which the document was written.</p>
<ul>
<li>indent (String) - preferred indentation</li>
<li>newline (String) - preferred newline</li>
<li>quote (String) - <code>&quot;</code> or <code>&#39;</code> depending on which quote is preferred</li>
<li>quote_keys (Boolean) - <code>true</code> if unquoted keys were used at least once</li>
<li>has_whitespace (Boolean) - <code>true</code> if input has a whitespace token</li>
<li>has_comments (Boolean) - <code>true</code> if input has a comment token</li>
<li>has_newlines (Boolean) - <code>true</code> if input has a newline token</li>
<li>has_trailing_comma (Boolean) - <code>true</code> if input has at least one trailing comma</li>
</ul>
<h3><a name="jjuupdate-function" class="anchor" href="#jjuupdate-function"><span class="header-link"></span></a>jju.update() function</h3><pre><code class="lang-js"><span class="hljs-comment">/*
 * Main syntax:
 *
 * `text` - original text, type: String
 * `new_value` - new value you want to set
 * `options` - parser or stringifier options, type: Object
 */</span>
jju.tokenize(text, new_value[, options])
</code></pre>
<p>If you want to update a JSON document, here is the general approach:</p>
<pre><code class="lang-js"><span class="hljs-comment">// here is your original JSON document:</span>
<span class="hljs-keyword">var</span> input = <span class="hljs-string">'{"foo": "bar", "baz": 123}'</span>

<span class="hljs-comment">// you need to parse it first:</span>
<span class="hljs-keyword">var</span> json = jju.parse(input, {mode: <span class="hljs-string">'json'</span>})
<span class="hljs-comment">// json is { foo: 'bar', baz: 123 }</span>

<span class="hljs-comment">// then you can change it as you like:</span>
json.foo = <span class="hljs-string">'quux'</span>
json.hello = <span class="hljs-string">'world'</span>

<span class="hljs-comment">// then you run an update function to change the original json:</span>
<span class="hljs-keyword">var</span> output = jju.update(input, json, {mode: <span class="hljs-string">'json'</span>})
<span class="hljs-comment">// output is '{"foo": "quux", "baz": 123, "hello": "world"}'</span>
</code></pre>
<p>Look at <a href="http://rlidwka.github.io/jju/editor.html">this demo</a> to test various types of json.</p>
<h2><a name="advantages-over-existing-json-libraries" class="anchor" href="#advantages-over-existing-json-libraries"><span class="header-link"></span></a>Advantages over existing JSON libraries</h2><p>In a few cases it makes sense to use this module instead of built-in JSON methods.</p>
<p>Parser:</p>
<ul>
<li>better error reporting with source code and line numbers</li>
</ul>
<p>In case of syntax error, JSON.parse does not return any good information to the user. This module does:</p>
<pre><code>$ node -e <span class="hljs-attribute">'require</span>(<span class="hljs-string">"jju"</span>).parse(<span class="hljs-string">"[1,1,1,1,invalid]"</span>)'

SyntaxError: Unexpected token <span class="hljs-attribute">'i</span>' at <span class="hljs-number">0</span>:<span class="hljs-number">9</span>
[<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,invalid]
         ^
</code></pre><p>This module is about 5 times slower, so if user experience matters to you more than performance, use this module. If you&#39;re working with a lot of machine-generated data, use JSON.parse instead.</p>
<p>Stringifier:</p>
<ul>
<li>util.inspect-like pretty printing</li>
</ul>
<p>This module behaves more smart when dealing with object and arrays, and does not always print newlines in them:</p>
<pre><code>$ node -e 'console.log(require(<span class="hljs-string">"./"</span>).stringify([[,,,],,,[,,,,]], {mode:<span class="hljs-string">"json"</span>}))'
[
        [null, null, null],
        null,
        null,
        [null, null, null, null]
]
</code></pre><p>JSON.stringify will split this into 15 lines, and it&#39;s hard to read.</p>
<p>Yet again, this feature comes with a performance hit, so if user experience matters to you more than performance, use this module. If your JSON will be consumed by machines, use JSON.stringify instead.</p>
<p>As a rule of thumb, if you use &quot;space&quot; argument to indent your JSON, you&#39;d better use this module instead.</p>
</div></div></body></html>